//
//  main.cpp
//  1, 2, 3 더하기
//
//  Created by 이영현 on 2021/07/03.
//  Copyright © 2021 이영현. All rights reserved.
//

#include <iostream>

using namespace std;
int dividedNum;
int tempSaveFinal = 3; // 마지막으로 저장된 수
int divideMemo[12] = {0, };

void divideFunc(int num)
{
    if(divideMemo[num] != 0) // 이미 저장되어있는 경우, 바로 출력
        cout<<divideMemo[num]<<'\n'; // 개행 빼먹지 말자 ^^..
    
    else
    {
        for(int i = tempSaveFinal + 1; i <= num;++i)
            divideMemo[i] = (divideMemo[i - 1] + divideMemo[i - 2] + divideMemo[i - 3]);
        tempSaveFinal = num;
        cout<<divideMemo[num]<<'\n';
    }
}

int main(int argc, const char * argv[]) {
    int testCase;
    cin>>testCase;
    
    divideMemo[1] = 1;
    divideMemo[2] = 2;
    divideMemo[3] = 4;
    
    for(int i = 0; i < testCase; ++i)
    {
        cin>>dividedNum;
        divideFunc(dividedNum);
    }
    
    return 0;
}

// 사고의 흐름
/*
 
 [0. 삽질 기록]
 
 문제를 어떻게 나누면 좋을까?
 어떤 경우의 수가 존재할지부터 먼저 생각해보자!
 (# 사람은 경우의 수를 생각할 때, 어떻게 생각할까?)
 
 1. 해당 수를 1로만 더하기 (default : 무조건 존재)
 2. 1로만 더한 걸 2로 묶는다.
    그런데 ex. 1+2+1이나 1+1+2같은 경우도 모두 다른 경우도 치는 것에 주의!
    2가 하나일때, 두 개일때, ... 가능한 경우를 모두 돌자
    * 배열의 원소를 짝짓는다고 생각해 보자
 3. 1+2나 2+1로 더해진 것은 3으로 묶을 수 있다.
 4. 그런데 위의 경우는 심플한 경우고, 어떻게 하면 1, 2, 3가 섞여있는 모든 경우를 중복 제외하고 생각할 수 있을까?
    (ex. 2+1+1은 3+1로 묶이지만 1+1+2나 1+2+1은 동일한 1+3으로 묶이는데 이 경우를 어떤 알고리즘으로 제거해줄까?)
    
 [1. 영균이의 내 질문 피드백 & 생각 정리]
 
 -> 알고리즘 선생님 영균이의 피드백
 1. 중복이 있다 -> DP
    다이나믹 프로그래밍은 완전탐색에서 중복된 탐색을 처리해서 좀더 빠르게 탐색하기 위해 쓰이고 있기 때문
 2. vs 브루트 포스
    완전탐색으로 만약 5를 구한다고 한다면 -> 1 + 1 + 2 + 1 과 1 + 1 + 1+ 2
    cf. 완전탐색의 경우 각각의 경우를 독립으로 생각하여 처음부터 1 + 1+ 2 + 1, 1+ 1+ 1+ 2를 구하겠지만
    다이나믹 프로그래밍은 처음 1+ 1부분이 중복되니 1 + 1을 구하는 방법의 경우부터 시작!
        -> 1 + 1을 다시 계산하지 않기 위해서 어딘가에 메모 (# 메모이제이션)
 
 Q1. 재귀로 푼다면 기저사례가 힘들 것 같아!
    -> 기저사례는 두 가지 방법이 있는데
    1) 1, 2, 3을 더하는 경우로 생각해보는 경우는 총 더한값이 n이 되는 경우로
    2) 1, 2, 3을 n에서 시작해서 빼는 경우로 생각한다면 남은 n이 1,2,3일때를 기저사례로 할 수 있다
 
 Q2. 사고의 흐름을 읽은 후
    해당 수를 1로만 더한 경우에서 일부분을 1 + 2나 1 + 3으로 묶는 경우는 너무 코드로 짜기 힘들 것 같다
    -> 그래서 1, 2, 3을 각각 독립된 경우로 생각해야 한다!
 
 Q3. 그렇다면 여기서 메모이제이션의 대상이 되는 것은 무엇인가?
    -> 왜 나눠질까? (# 기본 요소들)
        1을 1,2,3으로 표현하면 -> (1) : 1가지
        2를 1,2,3으로 표현하면 -> (1 + 1), (2) : 2가지
        3를 1,2,3으로 표현하면 -> (1 + 1 + 1), (1 + 2), (2 + 1), (3) : 4가지
    -> 이제 4에 대해서 생각해보자
        4는 1+3, 2+2, 3+1의 더하기로 표현될 수 있다
        여기서 느끼는 게 있지 않을까?
 
 [2. 삽질 기록]
        그렇다면 4의 경우의 수는 어떻게 될까?
        즉, 1+3 -> 1*4(4가지) + 2+2 -> 2*2(4가지) + 3+1 -> 1*4(3가지)
        그런데 이렇게 나누면 중복이 생겨서 원래의 답보다 더 커지는데..?
 
    -> 단순히 순서쌍 더하기가 아닌 것 같다. DP니까! 점화식을 찾아보자.
        4와 5에 대해서 바로 해보니까 찾았다..! n번째 = n-3 + n-2 + n-1 였다..
 
        * 왜 이런 점화식이 나왔는가? *
        n = n-3 + 3을 더한 것으로 표현이 가능
        n = n-2 + 2를 더한 것으로 표현이 가능
        n = n-1 + 1를 더한 것으로 표현이 가능
        따라서 n = n-3 + n-2 + n-1의 경우의 수로 표현이 되는 것
 */
